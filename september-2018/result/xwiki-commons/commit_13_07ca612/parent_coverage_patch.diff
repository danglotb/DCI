diff --git a/xwiki-commons-core/xwiki-commons-velocity/src/main/java/org/xwiki/velocity/introspection/MethodArgumentsUberspector.java b/xwiki-commons-core/xwiki-commons-velocity/src/main/java/org/xwiki/velocity/introspection/MethodArgumentsUberspector.java
index a092672..a4e899f 100644
--- a/xwiki-commons-core/xwiki-commons-velocity/src/main/java/org/xwiki/velocity/introspection/MethodArgumentsUberspector.java
+++ b/xwiki-commons-core/xwiki-commons-velocity/src/main/java/org/xwiki/velocity/introspection/MethodArgumentsUberspector.java
@@ -21,10 +21,8 @@
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
-import java.lang.reflect.Type;
 import java.util.Arrays;
 
-import org.apache.commons.lang3.reflect.TypeUtils;
 import org.apache.velocity.runtime.RuntimeServices;
 import org.apache.velocity.util.RuntimeServicesAware;
 import org.apache.velocity.util.introspection.AbstractChainableUberspector;
@@ -82,7 +80,7 @@ public VelMethod getMethod(Object obj, String methodName, Object[] args, Info i)
         // and a method that takes java.lang.Integer as a parameter."
         // Thus we need to apply the following logic:
         // - if the returned VelMethod has a different number of parameters than the signature asked for, then go into
-        // our conversion code
+        //   our conversion code
         // - if our conversion code doesn't find any match, then return the VelMethod found by Velocity.
 
         VelMethod initialVelMethod = super.getMethod(obj, methodName, args, i);
@@ -146,15 +144,15 @@ private Method getPrivateMethod(VelMethod velMethod) throws Exception
     {
         for (Method method : obj.getClass().getMethods()) {
             if (method.getName().equalsIgnoreCase(methodName)
-                && (method.getGenericParameterTypes().length == args.length || method.isVarArgs())) {
+//                && method.getParameterTypes().length == args.length) {
+                && (method.getParameterTypes().length == args.length || method.isVarArgs())) {
                 try {
-                    return convertArguments(args, method.getGenericParameterTypes(), method.isVarArgs());
+                    return convertArguments(args, method.getParameterTypes(), method.isVarArgs());
                 } catch (Exception e) {
                     // Ignore and try the next method.
                 }
             }
         }
-
         return null;
     }
 
@@ -168,24 +166,22 @@ private Method getPrivateMethod(VelMethod velMethod) throws Exception
      * @param isVarArgs true if the method contains a varargs (ie the last parameter is a varargs)
      * @return a new array of arguments where some values have been converted to match the formal method parameter types
      */
-    private Object[] convertArguments(Object[] arguments, Type[] parameterTypes, boolean isVarArgs)
+    private Object[] convertArguments(Object[] arguments, Class<?>[] parameterTypes, boolean isVarArgs)
     {
         Object[] convertedArguments = Arrays.copyOf(arguments, arguments.length);
         for (int i = 0; i < arguments.length; i++) {
             // Try to convert the argument if it's not null and if it doesn't match the parameter type.
             // If the method is a varargs then extract the type from the vararg array
-            Type expectedType;
+            Class<?> expectedClass;
             if (isVarArgs && i >= parameterTypes.length - 1) {
-                expectedType = ((Class<?>) parameterTypes[parameterTypes.length - 1]).getComponentType();
+                expectedClass = parameterTypes[parameterTypes.length - 1].getComponentType();
             } else {
-                expectedType = parameterTypes[i];
+                expectedClass = parameterTypes[i];
             }
-
-            if (arguments[i] != null && !TypeUtils.isInstance(arguments[i], expectedType)) {
-                convertedArguments[i] = this.converterManager.convert(expectedType, arguments[i]);
+            if (arguments[i] != null && !expectedClass.isInstance(arguments[i])) {
+                convertedArguments[i] = this.converterManager.convert(expectedClass, arguments[i]);
             }
         }
-
         return convertedArguments;
     }
 
diff --git a/xwiki-commons-core/xwiki-commons-velocity/src/test/java/org/xwiki/velocity/introspection/MethodArgumentUberspectorTest.java b/xwiki-commons-core/xwiki-commons-velocity/src/test/java/org/xwiki/velocity/introspection/MethodArgumentUberspectorTest.java
index 538194f..6368ede 100644
--- a/xwiki-commons-core/xwiki-commons-velocity/src/test/java/org/xwiki/velocity/introspection/MethodArgumentUberspectorTest.java
+++ b/xwiki-commons-core/xwiki-commons-velocity/src/test/java/org/xwiki/velocity/introspection/MethodArgumentUberspectorTest.java
@@ -23,7 +23,6 @@
 import java.io.StringWriter;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Locale;
 import java.util.Properties;
 
 import org.apache.commons.lang.exception.ExceptionUtils;
@@ -32,7 +31,6 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
-import org.xwiki.component.util.DefaultParameterizedType;
 import org.xwiki.properties.ConverterManager;
 import org.xwiki.test.annotation.BeforeComponent;
 import org.xwiki.test.annotation.ComponentList;
@@ -43,9 +41,8 @@
 import org.xwiki.velocity.internal.DefaultVelocityContextFactory;
 import org.xwiki.velocity.internal.DefaultVelocityEngine;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.when;
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
 
 /**
  * Unit tests for {@link org.xwiki.velocity.introspection.MethodArgumentsUberspector}.
@@ -53,7 +50,11 @@
  * @version $Id$
  * @since 6.4M3
  */
-@ComponentList({ DefaultVelocityEngine.class, DefaultVelocityConfiguration.class, DefaultVelocityContextFactory.class })
+@ComponentList({
+    DefaultVelocityEngine.class,
+    DefaultVelocityConfiguration.class,
+    DefaultVelocityContextFactory.class
+})
 public class MethodArgumentUberspectorTest
 {
     @Rule
@@ -93,15 +94,6 @@ public String method(List parameter)
             }
         }
 
-        public String methodWithGeneric(List<Locale> genericParameter)
-        {
-            if (genericParameter.get(0) instanceof Locale) {
-                return "success";
-            } else {
-                return "failure";
-            }
-        }
-
         public String methodWithVararg(Integer param1, Double... params)
         {
             StringBuilder builder = new StringBuilder("success");
@@ -158,7 +150,8 @@ public void getMethodWhenVarargsWithNoConversionAndTwoVarargParamsPassed() throw
     public void getMethodWhenVarargsWithConversionAndNoVarargParamPassed() throws Exception
     {
         when(this.converterManager.convert(Integer.class, "10")).thenReturn(10);
-        this.engine.evaluate(this.context, this.writer, "template", new StringReader("$var.methodWithVararg('10')"));
+        this.engine.evaluate(this.context, this.writer, "template",
+            new StringReader("$var.methodWithVararg('10')"));
         assertEquals("success", writer.toString());
     }
 
@@ -234,13 +227,4 @@ public void getMethodWhenExistingMethodNameButInvalidSignature() throws Exceptio
                 ExceptionUtils.getRootCauseMessage(expected));
         }
     }
-
-    @Test
-    public void getMethodWithGeneric() throws Exception
-    {
-        when(this.converterManager.convert(new DefaultParameterizedType(null, List.class, Locale.class), "en, fr"))
-            .thenReturn(Arrays.asList(Locale.ENGLISH, Locale.FRENCH));
-        this.engine.evaluate(this.context, this.writer, "template", new StringReader("$var.methodWithGeneric('en, fr')"));
-        assertEquals("success", this.writer.toString());
-    }
 }
