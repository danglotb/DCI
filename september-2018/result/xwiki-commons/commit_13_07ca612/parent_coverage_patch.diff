diff --git a/xwiki-commons-core/xwiki-commons-velocity/src/main/java/org/xwiki/velocity/introspection/MethodArgumentsUberspector.java b/xwiki-commons-core/xwiki-commons-velocity/src/main/java/org/xwiki/velocity/introspection/MethodArgumentsUberspector.java
index a4e899f4c..a09267204 100644
--- a/xwiki-commons-core/xwiki-commons-velocity/src/main/java/org/xwiki/velocity/introspection/MethodArgumentsUberspector.java
+++ b/xwiki-commons-core/xwiki-commons-velocity/src/main/java/org/xwiki/velocity/introspection/MethodArgumentsUberspector.java
@@ -21,8 +21,10 @@
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.lang.reflect.Type;
 import java.util.Arrays;
 
+import org.apache.commons.lang3.reflect.TypeUtils;
 import org.apache.velocity.runtime.RuntimeServices;
 import org.apache.velocity.util.RuntimeServicesAware;
 import org.apache.velocity.util.introspection.AbstractChainableUberspector;
@@ -80,7 +82,7 @@ public VelMethod getMethod(Object obj, String methodName, Object[] args, Info i)
         // and a method that takes java.lang.Integer as a parameter."
         // Thus we need to apply the following logic:
         // - if the returned VelMethod has a different number of parameters than the signature asked for, then go into
-        //   our conversion code
+        // our conversion code
         // - if our conversion code doesn't find any match, then return the VelMethod found by Velocity.
 
         VelMethod initialVelMethod = super.getMethod(obj, methodName, args, i);
@@ -144,15 +146,15 @@ private Method getPrivateMethod(VelMethod velMethod) throws Exception
     {
         for (Method method : obj.getClass().getMethods()) {
             if (method.getName().equalsIgnoreCase(methodName)
-//                && method.getParameterTypes().length == args.length) {
-                && (method.getParameterTypes().length == args.length || method.isVarArgs())) {
+                && (method.getGenericParameterTypes().length == args.length || method.isVarArgs())) {
                 try {
-                    return convertArguments(args, method.getParameterTypes(), method.isVarArgs());
+                    return convertArguments(args, method.getGenericParameterTypes(), method.isVarArgs());
                 } catch (Exception e) {
                     // Ignore and try the next method.
                 }
             }
         }
+
         return null;
     }
 
@@ -166,22 +168,24 @@ private Method getPrivateMethod(VelMethod velMethod) throws Exception
      * @param isVarArgs true if the method contains a varargs (ie the last parameter is a varargs)
      * @return a new array of arguments where some values have been converted to match the formal method parameter types
      */
-    private Object[] convertArguments(Object[] arguments, Class<?>[] parameterTypes, boolean isVarArgs)
+    private Object[] convertArguments(Object[] arguments, Type[] parameterTypes, boolean isVarArgs)
     {
         Object[] convertedArguments = Arrays.copyOf(arguments, arguments.length);
         for (int i = 0; i < arguments.length; i++) {
             // Try to convert the argument if it's not null and if it doesn't match the parameter type.
             // If the method is a varargs then extract the type from the vararg array
-            Class<?> expectedClass;
+            Type expectedType;
             if (isVarArgs && i >= parameterTypes.length - 1) {
-                expectedClass = parameterTypes[parameterTypes.length - 1].getComponentType();
+                expectedType = ((Class<?>) parameterTypes[parameterTypes.length - 1]).getComponentType();
             } else {
-                expectedClass = parameterTypes[i];
+                expectedType = parameterTypes[i];
             }
-            if (arguments[i] != null && !expectedClass.isInstance(arguments[i])) {
-                convertedArguments[i] = this.converterManager.convert(expectedClass, arguments[i]);
+
+            if (arguments[i] != null && !TypeUtils.isInstance(arguments[i], expectedType)) {
+                convertedArguments[i] = this.converterManager.convert(expectedType, arguments[i]);
             }
         }
+
         return convertedArguments;
     }
 
diff --git a/xwiki-commons-core/xwiki-commons-velocity/src/test/java/org/xwiki/velocity/introspection/MethodArgumentUberspectorTest.java b/xwiki-commons-core/xwiki-commons-velocity/src/test/java/org/xwiki/velocity/introspection/MethodArgumentUberspectorTest.java
index 6368ede27..538194fd8 100644
--- a/xwiki-commons-core/xwiki-commons-velocity/src/test/java/org/xwiki/velocity/introspection/MethodArgumentUberspectorTest.java
+++ b/xwiki-commons-core/xwiki-commons-velocity/src/test/java/org/xwiki/velocity/introspection/MethodArgumentUberspectorTest.java
@@ -23,6 +23,7 @@
 import java.io.StringWriter;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Locale;
 import java.util.Properties;
 
 import org.apache.commons.lang.exception.ExceptionUtils;
@@ -31,6 +32,7 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.xwiki.component.util.DefaultParameterizedType;
 import org.xwiki.properties.ConverterManager;
 import org.xwiki.test.annotation.BeforeComponent;
 import org.xwiki.test.annotation.ComponentList;
@@ -41,8 +43,9 @@
 import org.xwiki.velocity.internal.DefaultVelocityContextFactory;
 import org.xwiki.velocity.internal.DefaultVelocityEngine;
 
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.when;
 
 /**
  * Unit tests for {@link org.xwiki.velocity.introspection.MethodArgumentsUberspector}.
@@ -50,11 +53,7 @@
  * @version $Id$
  * @since 6.4M3
  */
-@ComponentList({
-    DefaultVelocityEngine.class,
-    DefaultVelocityConfiguration.class,
-    DefaultVelocityContextFactory.class
-})
+@ComponentList({ DefaultVelocityEngine.class, DefaultVelocityConfiguration.class, DefaultVelocityContextFactory.class })
 public class MethodArgumentUberspectorTest
 {
     @Rule
@@ -94,6 +93,15 @@ public String method(List parameter)
             }
         }
 
+        public String methodWithGeneric(List<Locale> genericParameter)
+        {
+            if (genericParameter.get(0) instanceof Locale) {
+                return "success";
+            } else {
+                return "failure";
+            }
+        }
+
         public String methodWithVararg(Integer param1, Double... params)
         {
             StringBuilder builder = new StringBuilder("success");
@@ -150,8 +158,7 @@ public void getMethodWhenVarargsWithNoConversionAndTwoVarargParamsPassed() throw
     public void getMethodWhenVarargsWithConversionAndNoVarargParamPassed() throws Exception
     {
         when(this.converterManager.convert(Integer.class, "10")).thenReturn(10);
-        this.engine.evaluate(this.context, this.writer, "template",
-            new StringReader("$var.methodWithVararg('10')"));
+        this.engine.evaluate(this.context, this.writer, "template", new StringReader("$var.methodWithVararg('10')"));
         assertEquals("success", writer.toString());
     }
 
@@ -227,4 +234,13 @@ public void getMethodWhenExistingMethodNameButInvalidSignature() throws Exceptio
                 ExceptionUtils.getRootCauseMessage(expected));
         }
     }
+
+    @Test
+    public void getMethodWithGeneric() throws Exception
+    {
+        when(this.converterManager.convert(new DefaultParameterizedType(null, List.class, Locale.class), "en, fr"))
+            .thenReturn(Arrays.asList(Locale.ENGLISH, Locale.FRENCH));
+        this.engine.evaluate(this.context, this.writer, "template", new StringReader("$var.methodWithGeneric('en, fr')"));
+        assertEquals("success", this.writer.toString());
+    }
 }
