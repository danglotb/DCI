diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index c5f88c1..a104656 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -10,6 +10,12 @@
     <!-- types are add, fix, remove, update -->
     <release version="2.9.10" date="SNAPSHOT" description="v2.9.10">
       <action dev="jodastephen" type="add">
+        Handle negative SAVE values in tzdb.
+        Once again, tzdb is the source of problems, with their inability to provide stability.
+        A hack has been added that reverses their latest decision to have negative SAVE values.
+        The hack works so long as a rule set does not mix positive and negative save values.
+      </action>
+      <action dev="jodastephen" type="add">
         Clarify negative durations.
         See #465.
       </action>
diff --git a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
index d8b87c3..4036b55 100644
--- a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
+++ b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
@@ -725,16 +725,16 @@ public class ZoneInfoCompiler {
         /**
          * Adds a recurring savings rule to the builder.
          */
-        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {
-            String nameKey = formatName(nameFormat);
-            iDateTimeOfYear.addRecurring
-                (builder, nameKey, iSaveMillis, iFromYear, iToYear);
+        public void addRecurring(DateTimeZoneBuilder builder, int negativeSave, String nameFormat) {
+            int saveMillis = iSaveMillis + -negativeSave;
+            String nameKey = formatName(nameFormat, saveMillis, iLetterS);
+            iDateTimeOfYear.addRecurring(builder, nameKey, saveMillis, iFromYear, iToYear);
         }
 
-        private String formatName(String nameFormat) {
+        private static String formatName(String nameFormat, int saveMillis, String letterS) {
             int index = nameFormat.indexOf('/');
             if (index > 0) {
-                if (iSaveMillis == 0) {
+                if (saveMillis == 0) {
                     // Extract standard name.
                     return nameFormat.substring(0, index).intern();
                 } else {
@@ -748,10 +748,10 @@ public class ZoneInfoCompiler {
             String left = nameFormat.substring(0, index);
             String right = nameFormat.substring(index + 2);
             String name;
-            if (iLetterS == null) {
+            if (letterS == null) {
                 name = left.concat(right);
             } else {
-                name = left + iLetterS + right;
+                name = left + letterS + right;
             }
             return name.intern();
         }
@@ -787,10 +787,34 @@ public class ZoneInfoCompiler {
         /**
          * Adds recurring savings rules to the builder.
          */
-        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {
-            for (int i=0; i<iRules.size(); i++) {
+        public void addRecurring(DateTimeZoneBuilder builder, int standardMillis, String nameFormat) {
+            // a hack is necessary to remove negative SAVE values from the input tzdb file
+            // negative save values cause the standard offset to be set in the summer instead of the winter
+            // this causes the wrong name to be chosen from the CLDR data
+
+            // check if the ruleset has negative SAVE values
+            int negativeSave = 0;
+            for (int i = 0; i < iRules.size(); i++) {
                 Rule rule = iRules.get(i);
-                rule.addRecurring(builder, nameFormat);
+                if (rule.iSaveMillis < 0) {
+                    negativeSave = Math.min(negativeSave, rule.iSaveMillis);
+                }
+            }
+            
+            // if negative SAVE values, then patch standard millis and name format
+            if (negativeSave < 0) {
+                standardMillis += negativeSave;
+                int slashPos = nameFormat.indexOf("/");
+                if (slashPos > 0) {
+                    nameFormat = nameFormat.substring(slashPos + 1) + "/" + nameFormat.substring(0, slashPos);
+                }
+            }
+            builder.setStandardOffset(standardMillis);
+            
+            // add each rule, passing through the negative save to alter the actual iSaveMillis value that is used
+            for (int i = 0; i < iRules.size(); i++) {
+                Rule rule = iRules.get(i);
+                rule.addRecurring(builder, negativeSave, nameFormat);
             }
         }
     }
@@ -857,14 +881,14 @@ public class ZoneInfoCompiler {
                                          Map<String, RuleSet> ruleSets)
         {
             for (; zone != null; zone = zone.iNext) {
-                builder.setStandardOffset(zone.iOffsetMillis);
-
                 if (zone.iRules == null) {
+                    builder.setStandardOffset(zone.iOffsetMillis);
                     builder.setFixedSavings(zone.iFormat, 0);
                 } else {
                     try {
                         // Check if iRules actually just refers to a savings.
                         int saveMillis = parseTime(zone.iRules);
+                        builder.setStandardOffset(zone.iOffsetMillis);
                         builder.setFixedSavings(zone.iFormat, saveMillis);
                     }
                     catch (Exception e) {
@@ -873,7 +897,7 @@ public class ZoneInfoCompiler {
                             throw new IllegalArgumentException
                                 ("Rules not found: " + zone.iRules);
                         }
-                        rs.addRecurring(builder, zone.iFormat);
+                        rs.addRecurring(builder, zone.iOffsetMillis, zone.iFormat);
                     }
                 }
 
diff --git a/src/test/java/org/joda/time/TestDateTimeZone.java b/src/test/java/org/joda/time/TestDateTimeZone.java
index 01ebc35..59654dc 100644
--- a/src/test/java/org/joda/time/TestDateTimeZone.java
+++ b/src/test/java/org/joda/time/TestDateTimeZone.java
@@ -1080,6 +1080,24 @@ public class TestDateTimeZone extends TestCase {
     }
 
     //-----------------------------------------------------------------------
+    public void testDublin() {
+        DateTimeZone zone = DateTimeZone.forID("Europe/Dublin");
+        DateTime winter = new DateTime(2018, 1, 1, 0, 0, 0, 0, zone);
+        assertEquals(0, zone.getStandardOffset(winter.getMillis()));
+        assertEquals(0, zone.getOffset(winter.getMillis()));
+        assertEquals(true, zone.isStandardOffset(winter.getMillis()));
+        assertEquals("Greenwich Mean Time", zone.getName(winter.getMillis()));
+        assertEquals("GMT", zone.getNameKey(winter.getMillis()));
+        
+        DateTime summer = winter.plusMonths(6);
+        assertEquals(0, zone.getStandardOffset(summer.getMillis()));
+        assertEquals(3600000, zone.getOffset(summer.getMillis()));
+        assertEquals(false, zone.isStandardOffset(summer.getMillis()));
+        assertEquals(true, zone.getName(summer.getMillis()).startsWith("Irish "));
+        assertEquals("IST", zone.getNameKey(summer.getMillis()));
+    }
+    
+    //-----------------------------------------------------------------------
     public void testSerialization1() throws Exception {
         DateTimeZone zone = DateTimeZone.forID("Europe/Paris");
         
