diff --git a/CHANGES b/CHANGES
index ff1d9f4..9169745 100644
--- a/CHANGES
+++ b/CHANGES
@@ -3,6 +3,10 @@ jsoup changelog
 **** Release 1.12.1 [PENDING]
   * Change: removed deprecated method to disable TLS cert checking Connection.validateTLSCertificates().
 
+  * Improvement: documents now remember their parser, so when later manipulating them, the correct HTML or XML tree
+    builder is reused, as are the parser settings like case sensitivity.
+    <https://github.com/jhy/jsoup/issues/769>
+
 *** Release 1.11.3 [2018-Apr-15]
   * Improvement: CDATA sections are now treated as whitespace preserving (regardless of the containing element), and are
     round-tripped into output HTML.
diff --git a/src/main/java/org/jsoup/nodes/Document.java b/src/main/java/org/jsoup/nodes/Document.java
index b7143bb..9d6a4ae 100644
--- a/src/main/java/org/jsoup/nodes/Document.java
+++ b/src/main/java/org/jsoup/nodes/Document.java
@@ -3,6 +3,7 @@ package org.jsoup.nodes;
 import org.jsoup.helper.StringUtil;
 import org.jsoup.helper.Validate;
 import org.jsoup.parser.ParseSettings;
+import org.jsoup.parser.Parser;
 import org.jsoup.parser.Tag;
 import org.jsoup.select.Elements;
 
@@ -17,6 +18,7 @@ import java.util.List;
  @author Jonathan Hedley, jonathan@hedley.net */
 public class Document extends Element {
     private OutputSettings outputSettings = new OutputSettings();
+    private Parser parser; // the parser used to parse this document
     private QuirksMode quirksMode = QuirksMode.noQuirks;
     private String location;
     private boolean updateMetaCharset = false;
@@ -41,6 +43,7 @@ public class Document extends Element {
         Validate.notNull(baseUri);
 
         Document doc = new Document(baseUri);
+        doc.parser = doc.parser();
         Element html = doc.appendElement("html");
         html.appendElement("head");
         html.appendElement("body");
@@ -573,4 +576,23 @@ public class Document extends Element {
         this.quirksMode = quirksMode;
         return this;
     }
+
+    /**
+     * Get the parser that was used to parse this document.
+     * @return the parser
+     */
+    public Parser parser() {
+        return parser;
+    }
+
+    /**
+     * Set the parser used to create this document. This parser is then used when further parsing within this document
+     * is required.
+     * @param parser the configured parser to use when further parsing is required for this document.
+     * @return this document, for chaining.
+     */
+    public Document parser(Parser parser) {
+        this.parser = parser;
+        return this;
+    }
 }
diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java
index 1f980e1..18da685 100644
--- a/src/main/java/org/jsoup/nodes/Element.java
+++ b/src/main/java/org/jsoup/nodes/Element.java
@@ -4,7 +4,6 @@ import org.jsoup.helper.ChangeNotifyingArrayList;
 import org.jsoup.helper.StringUtil;
 import org.jsoup.helper.Validate;
 import org.jsoup.parser.ParseSettings;
-import org.jsoup.parser.Parser;
 import org.jsoup.parser.Tag;
 import org.jsoup.select.Collector;
 import org.jsoup.select.Elements;
@@ -141,7 +140,7 @@ public class Element extends Node {
      */
     public Element tagName(String tagName) {
         Validate.notEmpty(tagName, "Tag name must not be empty.");
-        tag = Tag.valueOf(tagName, ParseSettings.preserveCase); // preserve the requested tag case
+        tag = Tag.valueOf(tagName, getParser().settings()); // maintains the case option of the original parse
         return this;
     }
 
@@ -483,7 +482,7 @@ public class Element extends Node {
      *  {@code parent.appendElement("h1").attr("id", "header").text("Welcome");}
      */
     public Element appendElement(String tagName) {
-        Element child = new Element(Tag.valueOf(tagName), baseUri());
+        Element child = new Element(Tag.valueOf(tagName, getParser().settings()), baseUri());
         appendChild(child);
         return child;
     }
@@ -496,7 +495,7 @@ public class Element extends Node {
      *  {@code parent.prependElement("h1").attr("id", "header").text("Welcome");}
      */
     public Element prependElement(String tagName) {
-        Element child = new Element(Tag.valueOf(tagName), baseUri());
+        Element child = new Element(Tag.valueOf(tagName, getParser().settings()), baseUri());
         prependChild(child);
         return child;
     }
@@ -535,8 +534,7 @@ public class Element extends Node {
      */
     public Element append(String html) {
         Validate.notNull(html);
-
-        List<Node> nodes = Parser.parseFragment(html, this, baseUri());
+        List<Node> nodes = getParser().parseFragmentInput(html, this, baseUri());
         addChildren(nodes.toArray(new Node[nodes.size()]));
         return this;
     }
@@ -549,8 +547,7 @@ public class Element extends Node {
      */
     public Element prepend(String html) {
         Validate.notNull(html);
-        
-        List<Node> nodes = Parser.parseFragment(html, this, baseUri());
+        List<Node> nodes = getParser().parseFragmentInput(html, this, baseUri());
         addChildren(0, nodes.toArray(new Node[nodes.size()]));
         return this;
     }
diff --git a/src/main/java/org/jsoup/nodes/Node.java b/src/main/java/org/jsoup/nodes/Node.java
index 37467a7..d7ad20a 100644
--- a/src/main/java/org/jsoup/nodes/Node.java
+++ b/src/main/java/org/jsoup/nodes/Node.java
@@ -3,6 +3,7 @@ package org.jsoup.nodes;
 import org.jsoup.SerializationException;
 import org.jsoup.helper.StringUtil;
 import org.jsoup.helper.Validate;
+import org.jsoup.parser.HtmlTreeBuilder;
 import org.jsoup.parser.Parser;
 import org.jsoup.select.NodeFilter;
 import org.jsoup.select.NodeTraversor;
@@ -77,12 +78,13 @@ public abstract class Node implements Cloneable {
 
     /**
      * Set an attribute (key=value). If the attribute already exists, it is replaced. The attribute key comparison is
-     * <b>case insensitive</b>.
+     * <b>case insensitive</b>. The key will be set with case sensitivity as set in the parser settings.
      * @param attributeKey The attribute key.
      * @param attributeValue The attribute value.
      * @return this (for chaining)
      */
     public Node attr(String attributeKey, String attributeValue) {
+        attributeKey = getParser().settings().normalizeAttribute(attributeKey);
         attributes().putIgnoreCase(attributeKey, attributeValue);
         return this;
     }
@@ -332,7 +334,7 @@ public abstract class Node implements Cloneable {
         Validate.notNull(parentNode);
 
         Element context = parent() instanceof Element ? (Element) parent() : null;
-        List<Node> nodes = Parser.parseFragment(html, context, baseUri());
+        List<Node> nodes = getParser().parseFragmentInput(html, context, baseUri());
         parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));
     }
 
@@ -345,7 +347,7 @@ public abstract class Node implements Cloneable {
         Validate.notEmpty(html);
 
         Element context = parent() instanceof Element ? (Element) parent() : null;
-        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());
+        List<Node> wrapChildren = getParser().parseFragmentInput(html, context, baseUri());
         Node wrapNode = wrapChildren.get(0);
         if (wrapNode == null || !(wrapNode instanceof Element)) // nothing to wrap with; noop
             return null;
@@ -579,6 +581,11 @@ public abstract class Node implements Cloneable {
         return owner != null ? owner.outputSettings() : (new Document("")).outputSettings();
     }
 
+    Parser getParser() {
+        Document doc = ownerDocument();
+        return doc != null && doc.parser() != null ? doc.parser() : new Parser(new HtmlTreeBuilder());
+    }
+
     /**
      Get the outer HTML of this node.
      @param accum accumulator to place HTML into
diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
index efc86bd..455bd6c 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
@@ -61,8 +61,8 @@ public class HtmlTreeBuilder extends TreeBuilder {
     }
 
     @Override
-    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {
-        super.initialiseParse(input, baseUri, errors, settings);
+    protected void initialiseParse(Reader input, String baseUri, Parser parser) {
+        super.initialiseParse(input, baseUri, parser);
 
         // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.
         state = HtmlTreeBuilderState.Initial;
@@ -79,10 +79,10 @@ public class HtmlTreeBuilder extends TreeBuilder {
         fragmentParsing = false;
     }
 
-    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {
+    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {
         // context may be null
         state = HtmlTreeBuilderState.Initial;
-        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);
+        initialiseParse(new StringReader(inputFragment), baseUri, parser);
         contextElement = context;
         fragmentParsing = true;
         Element root = null;
@@ -190,8 +190,8 @@ public class HtmlTreeBuilder extends TreeBuilder {
     }
 
     void error(HtmlTreeBuilderState state) {
-        if (errors.canAddError())
-            errors.add(new ParseError(reader.pos(), "Unexpected token [%s] when in state [%s]", currentToken.tokenType(), state));
+        if (parser.getErrors().canAddError())
+            parser.getErrors().add(new ParseError(reader.pos(), "Unexpected token [%s] when in state [%s]", currentToken.tokenType(), state));
     }
 
     Element insert(Token.StartTag startTag) {
diff --git a/src/main/java/org/jsoup/parser/ParseSettings.java b/src/main/java/org/jsoup/parser/ParseSettings.java
index 25a9b86..71bb4ce 100644
--- a/src/main/java/org/jsoup/parser/ParseSettings.java
+++ b/src/main/java/org/jsoup/parser/ParseSettings.java
@@ -35,14 +35,14 @@ public class ParseSettings {
         preserveAttributeCase = attribute;
     }
 
-    String normalizeTag(String name) {
+    public String normalizeTag(String name) {
         name = name.trim();
         if (!preserveTagCase)
             name = lowerCase(name);
         return name;
     }
 
-    String normalizeAttribute(String name) {
+    public String normalizeAttribute(String name) {
         name = name.trim();
         if (!preserveAttributeCase)
             name = lowerCase(name);
diff --git a/src/main/java/org/jsoup/parser/Parser.java b/src/main/java/org/jsoup/parser/Parser.java
index f3e99e1..919c9db 100644
--- a/src/main/java/org/jsoup/parser/Parser.java
+++ b/src/main/java/org/jsoup/parser/Parser.java
@@ -16,7 +16,6 @@ public class Parser {
     private static final int DEFAULT_MAX_ERRORS = 0; // by default, error tracking is disabled.
     
     private TreeBuilder treeBuilder;
-    private int maxErrors = DEFAULT_MAX_ERRORS;
     private ParseErrorList errors;
     private ParseSettings settings;
 
@@ -27,18 +26,20 @@ public class Parser {
     public Parser(TreeBuilder treeBuilder) {
         this.treeBuilder = treeBuilder;
         settings = treeBuilder.defaultSettings();
+        errors = ParseErrorList.noTracking();
     }
     
     public Document parseInput(String html, String baseUri) {
-        errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();
-        return treeBuilder.parse(new StringReader(html), baseUri, errors, settings);
+        return treeBuilder.parse(new StringReader(html), baseUri, this);
     }
 
     public Document parseInput(Reader inputHtml, String baseUri) {
-        errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();
-        return treeBuilder.parse(inputHtml, baseUri, errors, settings);
+        return treeBuilder.parse(inputHtml, baseUri, this);
     }
 
+    public List<Node> parseFragmentInput(String fragment, Element context, String baseUri) {
+        return treeBuilder.parseFragment(fragment, context, baseUri, this);
+    }
     // gets & sets
     /**
      * Get the TreeBuilder currently in use.
@@ -55,6 +56,7 @@ public class Parser {
      */
     public Parser setTreeBuilder(TreeBuilder treeBuilder) {
         this.treeBuilder = treeBuilder;
+        treeBuilder.parser = this;
         return this;
     }
 
@@ -63,7 +65,7 @@ public class Parser {
      * @return current track error state.
      */
     public boolean isTrackErrors() {
-        return maxErrors > 0;
+        return errors.getMaxSize() > 0;
     }
 
     /**
@@ -72,7 +74,7 @@ public class Parser {
      * @return this, for chaining
      */
     public Parser setTrackErrors(int maxErrors) {
-        this.maxErrors = maxErrors;
+        errors = maxErrors > 0 ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();
         return this;
     }
 
@@ -80,7 +82,7 @@ public class Parser {
      * Retrieve the parse errors, if any, from the last parse.
      * @return list of parse errors, up to the size of the maximum errors tracked.
      */
-    public List<ParseError> getErrors() {
+    public ParseErrorList getErrors() {
         return errors;
     }
 
@@ -104,7 +106,7 @@ public class Parser {
      */
     public static Document parse(String html, String baseUri) {
         TreeBuilder treeBuilder = new HtmlTreeBuilder();
-        return treeBuilder.parse(new StringReader(html), baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());
+        return treeBuilder.parse(new StringReader(html), baseUri, new Parser(treeBuilder));
     }
 
     /**
@@ -119,7 +121,7 @@ public class Parser {
      */
     public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {
         HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();
-        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());
+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, new Parser(treeBuilder));
     }
 
     /**
@@ -135,7 +137,9 @@ public class Parser {
      */
     public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) {
         HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();
-        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, errorList, treeBuilder.defaultSettings());
+        Parser parser = new Parser(treeBuilder);
+        parser.errors = errorList;
+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, parser);
     }
 
     /**
@@ -147,7 +151,7 @@ public class Parser {
      */
     public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {
         XmlTreeBuilder treeBuilder = new XmlTreeBuilder();
-        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());
+        return treeBuilder.parseFragment(fragmentXml, baseUri, new Parser(treeBuilder));
     }
 
     /**
diff --git a/src/main/java/org/jsoup/parser/TreeBuilder.java b/src/main/java/org/jsoup/parser/TreeBuilder.java
index 6833043..75dd91a 100644
--- a/src/main/java/org/jsoup/parser/TreeBuilder.java
+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java
@@ -4,48 +4,52 @@ import org.jsoup.helper.Validate;
 import org.jsoup.nodes.Attributes;
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.Element;
+import org.jsoup.nodes.Node;
 
 import java.io.Reader;
 import java.util.ArrayList;
+import java.util.List;
 
 /**
  * @author Jonathan Hedley
  */
 abstract class TreeBuilder {
+    protected Parser parser;
     CharacterReader reader;
     Tokeniser tokeniser;
     protected Document doc; // current doc we are building into
     protected ArrayList<Element> stack; // the stack of open elements
     protected String baseUri; // current base uri, for creating new elements
     protected Token currentToken; // currentToken is used only for error tracking.
-    protected ParseErrorList errors; // null when not tracking errors
     protected ParseSettings settings;
 
     private Token.StartTag start = new Token.StartTag(); // start tag to process
     private Token.EndTag end  = new Token.EndTag();
-
     abstract ParseSettings defaultSettings();
 
-    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {
+    protected void initialiseParse(Reader input, String baseUri, Parser parser) {
         Validate.notNull(input, "String input must not be null");
         Validate.notNull(baseUri, "BaseURI must not be null");
 
         doc = new Document(baseUri);
-        this.settings = settings;
+        doc.parser(parser);
+        this.parser = parser;
+        settings = parser.settings();
         reader = new CharacterReader(input);
-        this.errors = errors;
         currentToken = null;
-        tokeniser = new Tokeniser(reader, errors);
+        tokeniser = new Tokeniser(reader, parser.getErrors());
         stack = new ArrayList<>(32);
         this.baseUri = baseUri;
     }
 
-    Document parse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {
-        initialiseParse(input, baseUri, errors, settings);
+    Document parse(Reader input, String baseUri, Parser parser) {
+        initialiseParse(input, baseUri, parser);
         runParser();
         return doc;
     }
 
+    abstract List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser);
+
     protected void runParser() {
         while (true) {
             Token token = tokeniser.read();
diff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java
index aec5ba7..f4b782e 100644
--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java
+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java
@@ -2,7 +2,14 @@ package org.jsoup.parser;
 
 import org.jsoup.Jsoup;
 import org.jsoup.helper.Validate;
-import org.jsoup.nodes.*;
+import org.jsoup.nodes.CDataNode;
+import org.jsoup.nodes.Comment;
+import org.jsoup.nodes.Document;
+import org.jsoup.nodes.DocumentType;
+import org.jsoup.nodes.Element;
+import org.jsoup.nodes.Node;
+import org.jsoup.nodes.TextNode;
+import org.jsoup.nodes.XmlDeclaration;
 
 import java.io.Reader;
 import java.io.StringReader;
@@ -20,19 +27,19 @@ public class XmlTreeBuilder extends TreeBuilder {
         return ParseSettings.preserveCase;
     }
 
-    Document parse(Reader input, String baseUri) {
-        return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);
+    @Override
+    protected void initialiseParse(Reader input, String baseUri, Parser parser) {
+        super.initialiseParse(input, baseUri, parser);
+        stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)
+        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);
     }
 
-    Document parse(String input, String baseUri) {
-        return parse(new StringReader(input), baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);
+    Document parse(Reader input, String baseUri) {
+        return parse(input, baseUri, new Parser(this));
     }
 
-    @Override
-    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {
-        super.initialiseParse(input, baseUri, errors, settings);
-        stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)
-        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);
+    Document parse(String input, String baseUri) {
+        return parse(new StringReader(input), baseUri, new Parser(this));
     }
 
     @Override
@@ -137,9 +144,14 @@ public class XmlTreeBuilder extends TreeBuilder {
         }
     }
 
-    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {
-        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);
+
+    List<Node> parseFragment(String inputFragment, String baseUri, Parser parser) {
+        initialiseParse(new StringReader(inputFragment), baseUri, parser);
         runParser();
         return doc.childNodes();
     }
+
+    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {
+        return parseFragment(inputFragment, baseUri, parser);
+    }
 }
diff --git a/src/test/java/org/jsoup/nodes/ElementTest.java b/src/test/java/org/jsoup/nodes/ElementTest.java
index 39f452b..70a58f0 100644
--- a/src/test/java/org/jsoup/nodes/ElementTest.java
+++ b/src/test/java/org/jsoup/nodes/ElementTest.java
@@ -384,8 +384,8 @@ public class ElementTest {
         Element div = doc.getElementById("1");
         div.appendElement("p").text("there");
         div.appendElement("P").attr("CLASS", "second").text("now");
-        // manually specifying tag and attributes should now preserve case, regardless of parse mode
-        assertEquals("<html><head></head><body><div id=\"1\"><p>Hello</p><p>there</p><P CLASS=\"second\">now</P></div></body></html>",
+        // manually specifying tag and attributes should maintain case based on parser settings
+        assertEquals("<html><head></head><body><div id=\"1\"><p>Hello</p><p>there</p><p class=\"second\">now</p></div></body></html>",
                 TextUtil.stripNewlines(doc.html()));
 
         // check sibling index (with short circuit on reindexChildren):
diff --git a/src/test/java/org/jsoup/parser/HtmlParserTest.java b/src/test/java/org/jsoup/parser/HtmlParserTest.java
index 4032e7c..f583ed6 100644
--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java
+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java
@@ -1062,6 +1062,10 @@ public class HtmlParserTest {
         String html = "<!doctype HTML><DIV ID=1>One</DIV>";
         Document doc = Jsoup.parse(html);
         assertEquals("<!doctype html> <html> <head></head> <body> <div id=\"1\"> One </div> </body> </html>", StringUtil.normaliseWhitespace(doc.outerHtml()));
+
+        Element div = doc.selectFirst("#1");
+        div.after("<TaG>One</TaG>");
+        assertEquals("<tag>One</tag>", TextUtil.stripNewlines(div.nextElementSibling().outerHtml()));
     }
 
     @Test public void canPreserveTagCase() {
@@ -1069,6 +1073,10 @@ public class HtmlParserTest {
         parser.settings(new ParseSettings(true, false));
         Document doc = parser.parseInput("<div id=1><SPAN ID=2>", "");
         assertEquals("<html> <head></head> <body> <div id=\"1\"> <SPAN id=\"2\"></SPAN> </div> </body> </html>", StringUtil.normaliseWhitespace(doc.outerHtml()));
+
+        Element div = doc.selectFirst("#1");
+        div.after("<TaG ID=one>One</TaG>");
+        assertEquals("<TaG id=\"one\">One</TaG>", TextUtil.stripNewlines(div.nextElementSibling().outerHtml()));
     }
 
     @Test public void canPreserveAttributeCase() {
@@ -1076,6 +1084,10 @@ public class HtmlParserTest {
         parser.settings(new ParseSettings(false, true));
         Document doc = parser.parseInput("<div id=1><SPAN ID=2>", "");
         assertEquals("<html> <head></head> <body> <div id=\"1\"> <span ID=\"2\"></span> </div> </body> </html>", StringUtil.normaliseWhitespace(doc.outerHtml()));
+
+        Element div = doc.selectFirst("#1");
+        div.after("<TaG ID=one>One</TaG>");
+        assertEquals("<tag ID=\"one\">One</tag>", TextUtil.stripNewlines(div.nextElementSibling().outerHtml()));
     }
 
     @Test public void canPreserveBothCase() {
@@ -1083,6 +1095,10 @@ public class HtmlParserTest {
         parser.settings(new ParseSettings(true, true));
         Document doc = parser.parseInput("<div id=1><SPAN ID=2>", "");
         assertEquals("<html> <head></head> <body> <div id=\"1\"> <SPAN ID=\"2\"></SPAN> </div> </body> </html>", StringUtil.normaliseWhitespace(doc.outerHtml()));
+
+        Element div = doc.selectFirst("#1");
+        div.after("<TaG ID=one>One</TaG>");
+        assertEquals("<TaG ID=\"one\">One</TaG>", TextUtil.stripNewlines(div.nextElementSibling().outerHtml()));
     }
 
     @Test public void handlesControlCodeInAttributeName() {
diff --git a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java
index 9b1775e..08edc75 100644
--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java
+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java
@@ -9,6 +9,7 @@ import org.jsoup.nodes.Element;
 import org.jsoup.nodes.Node;
 import org.jsoup.nodes.TextNode;
 import org.jsoup.nodes.XmlDeclaration;
+import org.jsoup.select.Elements;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -184,6 +185,15 @@ public class XmlTreeBuilderTest {
         assertEquals("<CHECK>One</CHECK><TEST ID=\"1\">Check</TEST>", TextUtil.stripNewlines(doc.html()));
     }
 
+    @Test
+    public void appendPreservesCaseByDefault() {
+        String xml = "<One>One</One>";
+        Document doc = Jsoup.parse(xml, "", Parser.xmlParser());
+        Elements one = doc.select("One");
+        one.append("<Two ID=2>Two</Two>");
+        assertEquals("<One>One<Two ID=\"2\">Two</Two></One>", TextUtil.stripNewlines(doc.html()));
+    }
+
     @Test
     public void canNormalizeCase() {
         String xml = "<TEST ID=1>Check</TEST>";
